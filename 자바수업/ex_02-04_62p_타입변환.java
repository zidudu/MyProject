public class Hello2030 {
	
	//타입변환: 변수나 상수 혹은 리터럴을 다른 타입으로 변환하는 것을 말함
	// long m =25; double d = 3.14*10; 같이 치환문이나 수식 내에서 타입 일치하지 않을때,
	//컴파일러는 작은 타입을 큰 타입으로 자동 변환함
	// 리터럴 25는 int 타입으로서 long 타입으로 자동 변환된다.
	// 3.14*10에서 10은 실수 연산 하기 위해 10.0으로 자동 변환된다.
	//강제 타입변환:
	// int n=300;byte b=n;에서 n(300)을 byte 타입(0~255범위)으로 자동 변환하면, 
	//변수 b에 300이 저장되지 않고 44(300%256=44)가 저장되어 손실 발생
	// -> 컴파일러는 이 경우와 같이 작은 타입 변환할때 자동변환 대신 컴파일 오류 발생시킴
	// => 개발자가 손실 발생한다는 사실 알고도 변환하길 원하면 byte b=(byte)n; 과 같이 타입을 강제로 지정해야 함.
	// n을 byte 타입으로 강제 변환하여 44가 b에 들어간다.
	//double d =1.9; int n =(int)d; 에서 실수가 정수로 강제 변환되어 소수점 이하의 손실 발생함/
	
	// 캐스팅: 강제 타입 변환
	
	//메인 함수
	public static void main(String[] args) {
		byte b=127;
		int i=100;
		System.out.println(b+i); // 127 + 100에서 b가 int 타입으로 자동 변환된다. 그래서 227
		System.out.println(10 / 4); // 정수 값에 정수로 나눠서 int 값 2가 나온다.
		System.out.println(10.0 / 4); //실수가 앞에 있기 때문에 뒤에있는 4가 4.0으로 자동변환된다. => 10.0/4.0 = 2.5
		System.out.println((char)0x12340041);  
		//0x12340041는 16진수 리터럴로, 32비트(4바이트) 정수 값이다.
		// 0x12340041 = 3053973185 (10진수)
		// 그러나 char 로 캐스팅 된다. char는 16비트(2바이트) 유니코드 문자 타입이다.
		// 하지만 0x12340041는 32비트이므로, 캐스팅할때 하위 16비트만 유지된다.
		//그래서 0x12340041 = 0b00010010001101000000000001000001 에서 하위 16비트만 취하게 되면
		// 0000000001000001 => 0x0041(16) => 65(십) => A (유니코드) 로 출력이 된다. 
		
		System.out.println((byte)(b+i)); // 227인데 16진수로는 0xE3(16*14+3)인데
		// byte 타입은 1바이트(8비트, -128 ~ 127)이다. 227을 바이트로 변환하면 오버플로우가 발생한다.
		// 오버플로우 발생하면 256을 빼서 변환된다. -> 227-256 = -29 가 나오게 된다.
		
		System.out.println((int)2.9 + 1.8); // 2.9를 int로 변환-> 2, 1.8과 더하니 2.0으로 변환-> 2.0+ 1.8 = 3.8
		System.out.println(1.8 +(int)2.9); 
		//[실험 : 우선순위 바꿔서 출력해보기 -> 결과 : 3.8이 나온다. 이유: 1.8은 double(실수, 8바이트)타입이다. 그리고 int는 4바이트이다.
		// 자동변환은 작은타입에서 큰타입으로 자동변환하기 때문에 int로 변환된 2도 double로 변환되어 2.0이 된다.]
		System.out.println((int)(2.9 + 1.8)); // 두 값을 더하면 4.7이 되고, 이걸 int로 변환하면 4가 된다.
		System.out.println((int)2.9 + (int)1.8); // 둘다 int로 변환하여 더하면 2+1=3이 된다.
	}
}


/*
 
227
2
2.5
A
-29
3.8
3.8
4
3

*/
